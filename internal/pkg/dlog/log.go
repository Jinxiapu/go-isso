// Add debug mode for stdlib log.
// Flag `Llongfile` will be set if in debug mode while not set `Llongfile` or `Lshortfile`.
// Flag `Llongfile` or `Lshortfile` will be disabled if not in debug mode.
package dlog

import (
	"fmt"
	"io"
	"log"
)

// These flags define which text to prefix to each log entry generated by the Logger.
// Bits are or'ed together to control what's printed.
// There is no control over the order they appear (the order listed
// here) or the format they present (as described in the comments).
// The prefix is followed by a colon only when Llongfile or Lshortfile
// is specified.
// For example, flags Ldate | Ltime (or LstdFlags) produce,
//	2009/01/23 01:23:23 message
// while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
//	2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
const (
	Ldate         = 1 << iota     // the date in the local time zone: 2009/01/23
	Ltime                         // the time in the local time zone: 01:23:23
	Lmicroseconds                 // microsecond resolution: 01:23:23.123123.  assumes Ltime.
	Llongfile                     // full file name and line number: /a/b/c/d.go:23
	Lshortfile                    // final file name element and line number: d.go:23. overrides Llongfile
	LUTC                          // if Ldate or Ltime is set, use UTC rather than the local time zone
	LstdFlags     = Ldate | Ltime // initial values for the standard logger
)

type Logger struct {
	*log.Logger
	debug bool
}

// New creates a new Logger. The out variable sets the
// destination to which log data will be written.
// The prefix appears at the beginning of each generated log line.
// The flag argument defines the logging properties.
// The debug argument defines whether the logger is in debug mode.
// Flag `Llongfile` will be set if in debug mode while not set `Llongfile` or `Lshortfile`.
// Flag `Llongfile` or `Lshortfile` will be disabled if not in debug mode.
func New(out io.Writer, prefix string, flag int, debug bool) *Logger {
	if !debug {
		// if not in debug mode. Disable expensive flag.
		flag &= ^(log.Lshortfile | log.Llongfile)
	} else {
		// if in debug mode while not set `Llongfile` or `Lshortfile`.
		// Add `Llongfile` Flag.
		if flag&(Lshortfile|Llongfile) == 0 {
			flag |= log.Lshortfile
		}
	}
	return &Logger{log.New(out, prefix, flag), debug}
}

func (l *Logger) Debug(v ...interface{}) {
	if l.debug {
		_ = l.Output(2, "[DEBUG] "+fmt.Sprint(v...))
	}

}

func (l *Logger) Debugf(format string, v ...interface{}) {
	if l.debug {
		_ = l.Output(2, "[DEBUG] "+fmt.Sprintf(format, v...))
	}
}

func (l *Logger) Debugln(v ...interface{}) {
	if l.debug {
		_ = l.Output(2, "[DEBUG] "+fmt.Sprintln(v...))
	}
}

func (l *Logger) Info(v ...interface{}) {
	_ = l.Output(2, "[INFO] "+fmt.Sprint(v...))

}

func (l *Logger) Infof(format string, v ...interface{}) {
	_ = l.Output(2, "[INFO] "+fmt.Sprintf(format, v...))
}

func (l *Logger) Infoln(v ...interface{}) {
	_ = l.Output(2, "[INFO] "+fmt.Sprintln(v...))
}
